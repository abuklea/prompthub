# PromptHub - Implementation Plan

## Phase 1: Project Initialization and Core Setup

- Step 1: [P] Initial Project Setup & Dependency Installation
  - **Task**: Initialize a new Next.js project using the App Router, TypeScript, and Tailwind CSS. Install all core dependencies specified in the technical documentation, including Prisma, Zod, Supabase clients, shadcn/ui, Zustand, Framer Motion, and Monaco Editor. Configure TypeScript (`tsconfig.json`) and Tailwind CSS (`tailwind.config.ts`) according to the project's style guide and structure.
  - **Assignee**: `Lead_Architect`
  - **Files**:
    - `package.json`: To add all project dependencies.
    - `tsconfig.json`: To configure TypeScript paths and strictness.
    - `tailwind.config.ts`: To set up theme variables, fonts, and plugins.
    - `next.config.mjs`: Basic Next.js configuration.
    - `.gitignore`: To exclude `node_modules`, `.env`, and other non-essential files.
  - **Step Dependencies**: None
  - **User Instructions**: Run `npm install` to verify all dependencies are installed correctly. The project should be able to start in development mode (`npm run dev`) without errors.

- Step 2: [P] Supabase Project Setup & Environment Configuration
  - **Task**: Create a new project on Supabase. Retrieve the project URL and anon key. Set up the `.env` file with the required Supabase and database URL variables (`NEXT_PUBLIC_SUPABASE_URL`, `NEXT_PUBLIC_SUPABASE_ANON_KEY`, `DATABASE_URL`, `DIRECT_URL`).
  - **Assignee**: `Database_Admin`
  - **Files**:
    - `.env`: To store all secret keys and environment variables.
    - `.env.example`: To provide a template for required environment variables.
  - **Step Dependencies**: None
  - **User Instructions**: Check the Supabase project dashboard to confirm it's running. Ensure the `.env` file is populated with the correct credentials.

- Step 3: [P] PRP Initialization and Documentation Structure
  - **Task**: Create the required project documentation and reporting structure. This includes the `PRPs/docs`, `PRPs/reports`, and `wip` folders. Generate the initial PRP start report detailing the full plan of execution.
  - **Assignee**: `Lead_Architect`
  - **Files**:
    - `PRPs/reports/prompthub-v1-INITIAL.md`: The initial plan document.
    - `PRPs/docs/.gitkeep`: To create the directory.
    - `wip/.gitkeep`: To create the directory.
  - **Step Dependencies**: None
  - **User Instructions**: Verify that the specified folder structure (`PRPs/docs`, `PRPs/reports`, `wip`) exists at the project root.

- Step 4: Prisma Schema Definition & Initial Migration
  - **Task**: Translate the data models from the technical specification into a `schema.prisma` file. Define all models: `Profile`, `Folder`, `Prompt`, `PromptVersion`, and `Tag`. Set up relations, indexes, and onDelete cascade behaviors. Run the initial Prisma migration to sync the schema with the Supabase database.
  - **Assignee**: `Database_Admin`
  - **Files**:
    - `prisma/schema.prisma`: To define the complete database schema.
    - `prisma/migrations/0000_initial_schema/migration.sql`: Generated by Prisma to create the initial database structure.
  - **Step Dependencies**: Phase 1, Step 2
  - **User Instructions**: Run `npx prisma migrate dev --name initial-schema`. Verify in the Supabase Table Editor that all tables (`Profile`, `Folder`, `Prompt`, etc.) and their respective columns have been created correctly.

- Step 5: [P] Global Styles & Theme Foundation
  - **Task**: Configure the global CSS file (`src/styles/globals.css`) with the base Tailwind directives. Define all color system CSS variables for both light and dark modes as specified in the UI/UX and Style guides. Set up the primary and monospace font families.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/styles/globals.css`: To implement the core color and typography theming variables.
    - `src/app/layout.tsx`: To apply the font classes to the root layout.
  - **Step Dependencies**: Phase 1, Step 1
  - **User Instructions**: Inspect the application in the browser. The background color and default font should match the style guide.

- Step 6: [P] Core Library & Utility Configuration
  - **Task**: Set up singleton instances for the Prisma client and Supabase client. Create a `src/lib/` directory to house these configurations, ensuring they are reusable throughout the application.
  - **Assignee**: `Backend_Engineer`
  - **Files**:
    - `src/lib/db.ts`: To export a single, global instance of the Prisma client.
    - `src/lib/supabase.ts`: To configure and export Supabase client instances for client-side and server-side usage.
    - `src/lib/utils.ts`: To initialize the `cn` utility function from `shadcn/ui`.
  - **Step Dependencies**: Phase 1, Step 1; Phase 1, Step 2
  - **User Instructions**: This is a configuration step. Code should compile without errors.

- Step 7: `shadcn/ui` Initialization and Core Component Setup
  - **Task**: Initialize `shadcn/ui` in the project. Install a foundational set of components that will be used globally, such as `Button`, `Input`, `Card`, and `Toast`.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `components.json`: Configuration file for `shadcn/ui`.
    - `src/components/ui/button.tsx`: The Button component.
    - `src/components/ui/input.tsx`: The Input component.
    - `src/components/ui/card.tsx`: The Card component.
    - `src/components/ui/toaster.tsx`: The Toaster component for notifications.
    - `src/app/layout.tsx`: To add the `<Toaster />` component to the root layout.
  - **Step Dependencies**: Phase 1, Step 1; Phase 1, Step 5
  - **User Instructions**: Start the dev server. The application should render correctly. No visual changes are expected yet, but the component files should exist.

## Phase 2: Authentication & User Management

- Step 1: [P] Supabase Auth Trigger for Profile Creation
  - **Task**: Write and execute a SQL script in the Supabase dashboard to create a trigger. This trigger will automatically insert a new row into the public `Profile` table whenever a new user signs up and is added to the `auth.users` table.
  - **Assignee**: `Database_Admin`
  - **Files**:
    - `wip/T2.1-supabase-profile-trigger.sql`: A working file containing the SQL for the trigger and function.
  - **Step Dependencies**: Phase 1, Step 4
  - **User Instructions**: In the Supabase SQL Editor, run the script to create the function and trigger. Manually add a test user in the Supabase Auth dashboard and verify that a corresponding entry is created in the `Profile` table.

- Step 2: [P] Authentication UI Components (Login/Sign Up Form)
  - **Task**: Create the authentication form component (`AuthForm.tsx`). This component will handle both sign-in and sign-up states, toggling between them. Style the form using `shadcn/ui` components (`Card`, `Input`, `Button`) according to the UI/UX guide.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/features/auth/components/AuthForm.tsx`: The main UI component for authentication.
    - `src/app/(auth)/login/page.tsx`: The route that will render the `AuthForm`.
    - `src/app/(auth)/layout.tsx`: A simple layout for centering the auth form on the page.
  - **Step Dependencies**: Phase 1, Step 7
  - **User Instructions**: Navigate to `/login`. A styled form for signing in and signing up should be visible and match the design specifications.

- Step 3: Authentication Server Actions (Sign Up, Sign In, Sign Out)
  - **Task**: Implement the backend logic for authentication using Next.js Server Actions. Create `signUp`, `signIn`, and `signOut` actions. Use Zod for input validation and the Supabase SSR client for handling authentication logic.
  - **Assignee**: `Backend_Engineer`
  - **Files**:
    - `src/features/auth/actions.ts`: To contain the `signUp`, `signIn`, and `signOut` server actions.
    - `src/features/auth/schemas.ts`: To define the Zod schemas for sign-up and sign-in forms.
    - `src/features/auth/components/AuthForm.tsx`: Update the form to invoke these server actions on submit.
  - **Step Dependencies**: Phase 1, Step 6; Phase 2, Step 2
  - **User Instructions**: Test the full authentication flow. A new user should be able to sign up, log out, and log back in. Check the Supabase Auth dashboard to confirm user creation.

- Step 4: Protected Route Middleware
  - **Task**: Implement Next.js middleware to protect application routes. The middleware will check for a valid user session using the Supabase SSR client. Unauthenticated users attempting to access protected routes (e.g., the main app) will be redirected to the `/login` page.
  - **Assignee**: `Security_Specialist`
  - **Files**:
    - `src/middleware.ts`: The middleware logic for protecting routes.
  - **Step Dependencies**: Phase 2, Step 3
  - **User Instructions**: After logging out, attempt to navigate directly to the application's root URL (`/`). You should be redirected to `/login`. After logging in, you should be redirected to the main application page.

- Step 5: Basic Application Layout and User Display
  - **Task**: Create the main three-pane application layout for authenticated users. This includes a placeholder for the folder sidebar, prompt list, and editor. Fetch the current user's data and display their name or email in the header, along with a functional "Sign Out" button.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/app/(app)/layout.tsx`: The main 3-pane layout for the authenticated application.
    - `src/app/(app)/page.tsx`: The default page shown to logged-in users.
    - `src/components/layout/Header.tsx`: A new component to display user info and the sign-out button.
  - **Step Dependencies**: Phase 2, Step 3; Phase 2, Step 4
  - **User Instructions**: Log in to the application. You should see a basic layout with a header displaying your user information and a working "Sign Out" button.

## Phase 3: Data Security and Core Data Access

- Step 1: Row Level Security (RLS) Policies
  - **Task**: Implement Row Level Security (RLS) policies for all tables containing user-specific data (`Profile`, `Folder`, `Prompt`, `Tag`). Write SQL policies that ensure users can only perform CRUD operations on their own data.
  - **Assignee**: `Security_Specialist`
  - **Files**:
    - `wip/T3.1-rls-policies.sql`: A working file containing all RLS policies for all tables.
  - **Step Dependencies**: Phase 2, Step 1
  - **User Instructions**: In the Supabase SQL Editor, enable RLS on all relevant tables and apply the policies. This is a critical security step and can be tested implicitly in subsequent steps as data access is implemented.

## Phase 4: Prompt Organization & Retrieval

- Step 1: [P] Folder Data Access Server Actions
  - **Task**: Create the server actions required for folder management. Implement `getRootFolders` and `getFolderChildren` to enable lazy-loading of the folder tree. These actions will use Prisma to query the database.
  - **Assignee**: `Backend_Engineer`
  - **Files**:
    - `src/features/folders/actions.ts`: To contain server actions for fetching folder data.
  - **Step Dependencies**: Phase 3, Step 1
  - **User Instructions**: This is a backend-only step. The actions should be implemented and ready for the frontend to consume.

- Step 2: [P] Zustand Store for UI State
  - **Task**: Set up a Zustand store to manage global UI state. The initial store will handle the expanded/collapsed state of folders in the folder tree and track the currently selected folder and prompt.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/stores/use-ui-store.ts`: The Zustand store definition for managing UI state.
  - **Step Dependencies**: Phase 1, Step 1
  - **User Instructions**: This is a setup step. The store should be created and ready to be used by UI components.

- Step 3: Folder Tree UI Component
  - **Task**: Build the `FolderTree.tsx` component. This component will fetch the initial root folders using the server action from Step 1. It will render `FolderItem` components recursively. Implement lazy-loading: when a user clicks to expand a folder, it should call the `getFolderChildren` action and render the sub-folders. Use the Zustand store to manage the expanded state.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/features/folders/components/FolderTree.tsx`: The main container for the folder hierarchy.
    - `src/features/folders/components/FolderItem.tsx`: A recursive component to display a single folder, its children, and handle expansion.
    - `src/app/(app)/layout.tsx`: Integrate the `FolderTree` component into the left sidebar.
  - **Step Dependencies**: Phase 4, Step 1; Phase 4, Step 2
  - **User Instructions**: Log in and view the application. The left sidebar should be empty initially. After creating some folders (in the next step), you should be able to see them, expand them to load sub-folders, and collapse them.

- Step 4: Folder Creation and Management Actions & UI
  - **Task**: Implement the `createFolder`, `renameFolder`, and `deleteFolder` server actions. Add UI elements (e.g., a "New Folder" button, context menus on folder items) to the `FolderTree` component to invoke these actions. Use optimistic or pessimistic updates with clear loading states. Use `revalidatePath` to ensure the folder tree refreshes after a mutation.
  - **Assignee**: `Backend_Engineer`
  - **Files**:
    - `src/features/folders/actions.ts`: Add the mutation server actions.
    - `src/features/folders/components/FolderTree.tsx`: Add the "New Folder" button.
    - `src/features/folders/components/FolderItem.tsx`: Add a context menu (using `shadcn/ui` DropdownMenu) for rename and delete actions.
  - **Step Dependencies**: Phase 4, Step 3
  - **User Instructions**: You should now be able to create new folders and nested sub-folders. Right-clicking a folder should allow you to rename or delete it. The UI should update automatically after each action.

- Step 5: Prompt List Component
  - **Task**: Create the `PromptList.tsx` component for the center pane. When a folder is selected in the `FolderTree`, this component should display a list of prompts within that folder. Implement the `getPromptsByFolder` server action.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/features/prompts/actions.ts`: To create the `getPromptsByFolder` server action.
    - `src/features/prompts/components/PromptList.tsx`: The UI component to display the list of prompts.
    - `src/app/(app)/layout.tsx`: Integrate the `PromptList` into the center pane of the layout.
  - **Step Dependencies**: Phase 4, Step 4
  - **User Instructions**: When you click on a folder in the left sidebar, the center pane should update to show a (currently empty) list of prompts for that folder.

## Phase 5: Prompt Editor & Version Control

- Step 1: [P] Monaco Editor Integration
  - **Task**: Create a wrapper component for the Monaco Editor (`Editor.tsx`). This component should be dynamically imported to prevent SSR issues. Configure it with a dark theme and basic options.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/features/editor/components/Editor.tsx`: The wrapper component for `@monaco-editor/react`.
  - **Step Dependencies**: Phase 1, Step 1
  - **User Instructions**: This is a foundational component. No direct UI to test yet, but the component should be ready for integration.

- Step 2: [P] Prompt Creation and Data Access
  - **Task**: Implement the `createPrompt` and `getPromptDetails` server actions. Add a "New Prompt" button to the `PromptList` component. When a new prompt is created or an existing one is selected, the right-hand pane should render the editor view.
  - **Assignee**: `Backend_Engineer`
  - **Files**:
    - `src/features/prompts/actions.ts`: Add `createPrompt` and `getPromptDetails` actions.
    - `src/features/prompts/components/PromptList.tsx`: Add the "New Prompt" button.
    - `src/features/editor/components/EditorPane.tsx`: A new component for the right pane that will contain the title input and the Monaco Editor.
    - `src/app/(app)/layout.tsx`: Integrate `EditorPane` into the right pane.
  - **Step Dependencies**: Phase 4, Step 5; Phase 5, Step 1
  - **User Instructions**: In a selected folder, click "New Prompt". A new prompt should appear in the center list, and the right pane should display an editor view with an empty title and content area.

- Step 3: Prompt Saving and Versioning Logic
  - **Task**: Implement the `saveNewVersion` server action. This action will receive the prompt's new content, calculate a diff from the most recent version, and store this diff in the `PromptVersions` table. It will also update the main `content` field in the `Prompts` table.
  - **Assignee**: `Backend_Engineer`
  - **Files**:
    - `src/features/editor/actions.ts`: To contain the `saveNewVersion` server action.
    - `package.json`: Add `diff-match-patch` dependency.
  - **Step Dependencies**: Phase 5, Step 2
  - **User Instructions**: This is a backend step. The logic for creating versions should be complete and ready for the UI to use.

- Step 3b: [P] Improved UI Update: Layout, Editor, Toolbars & Features
  - **Task**: Transform the UI from basic 3-panel layout into a professional application with: (1) Full-height Monaco editor with scrolling and toolbar, (2) Duplicate title prevention, (3) Subfolder creation capability, (4) Consistent panel subheaders with context-aware toolbars, (5) Comprehensive sort/filter systems for folders and documents, (6) Auto-save with manual versioning (auto-save updates current content, manual save creates versions), (7) Placeholder UI for future features (version history, dashboard, settings).
  - **Assignee**: `senior-frontend-engineer`, `ux-ui-designer`
  - **Files**:
    - **CREATE**: `src/components/layout/PanelSubheader.tsx` - Reusable subheader component
    - **CREATE**: `src/features/editor/hooks/useAutoSave.ts` - Debounced auto-save hook
    - **CREATE**: `src/features/editor/hooks/useLocalStorage.ts` - localStorage persistence hook
    - **CREATE**: `src/features/editor/schemas.ts` - Validation schemas
    - **CREATE**: `src/features/folders/components/FolderToolbar.tsx` - Folder operations toolbar
    - **CREATE**: `src/features/prompts/components/DocumentToolbar.tsx` - Document operations toolbar
    - **CREATE**: `src/app/(app)/dashboard/page.tsx` - Dashboard placeholder
    - **MODIFY**: `src/app/(app)/layout.tsx` - Add 3 subheaders, fix panel heights
    - **MODIFY**: `src/features/editor/components/EditorPane.tsx` - Fix flex layout for full-height Monaco
    - **MODIFY**: `src/features/editor/components/Editor.tsx` - Enable full Monaco features
    - **MODIFY**: `src/features/editor/actions.ts` - Add autoSavePrompt action
    - **MODIFY**: `src/features/folders/components/FolderItem.tsx` - Add recursive subfolder support
    - **MODIFY**: `src/features/folders/components/FolderTree.tsx` - Integrate toolbar
    - **MODIFY**: `src/features/prompts/actions.ts` - Add duplicate title validation
    - **MODIFY**: `src/features/prompts/components/PromptList.tsx` - Rename to "Documents", integrate toolbar
    - **MODIFY**: `src/stores/use-ui-store.ts` - Add sort/filter state
    - **MODIFY**: `src/lib/utils.ts` - Add debounce utility
    - **MODIFY**: `src/app/(app)/settings/page.tsx` - Add placeholder sections
  - **Step Dependencies**: Phase 5, Step 3
  - **User Instructions**: (1) Monaco editor extends from title to footer on all screen sizes, (2) Cannot create duplicate titles (case-insensitive), (3) Can create subfolders up to 5 levels, (4) Three aligned subheaders visible with toolbars, (5) Sort/filter controls functional, (6) Auto-save triggers after 500ms typing pause, Ctrl+S creates version, (7) Version history button present (disabled), dashboard/settings pages render. Full validation checklist and testing guide in `PRPs/P5S3b-improved-ui-update.md`.

- Step 3c: [P] Fix Subheader Layout with Resizable Columns
  - **Task**: Transform fixed-width 3-column layout into user-resizable layout with animated drag handles. Install `react-resizable-panels`, create AnimatedResizeHandle and ResizablePanelsLayout components, update main layout to use resizable panels, and add responsive classes to toolbars. Column widths persist in localStorage, handles animate smoothly toward cursor, and min/max constraints prevent UI breakage.
  - **Assignee**: `senior-frontend-engineer`, `qa-test-automation-engineer`
  - **Files**:
    - **CREATE**: `src/components/layout/AnimatedResizeHandle.tsx` - Custom drag handle with framer-motion animations
    - **CREATE**: `src/components/layout/ResizablePanelsLayout.tsx` - Client wrapper with PanelGroup
    - **MODIFY**: `src/app/(app)/layout.tsx` - Use ResizablePanelsLayout instead of fixed divs
    - **MODIFY**: `src/features/folders/components/FolderToolbar.tsx` - Add responsive classes
    - **MODIFY**: `src/features/prompts/components/DocumentToolbar.tsx` - Add responsive classes
    - **MODIFY**: `src/features/editor/components/EditorPane.tsx` - Verify responsive behavior
    - `package.json`: Add `react-resizable-panels` dependency
  - **Step Dependencies**: Phase 5, Step 3b
  - **User Instructions**: (1) Columns can be resized by dragging vertical separators, (2) Drag handles animate smoothly toward cursor when nearby and return to center when released, (3) Column widths persist across page reloads, (4) Toolbar content fits properly at all column widths without overflow, (5) Touch and keyboard navigation work correctly. Full implementation details and testing guide in `PRPs/P5S3c-fix-subheader-layout-resizable-columns.md`.

- Step 3d: [P] Compact UI and Monaco Editor Fix
  - **Task**: Reduce all UI text by 25-30% for a more compact, power-user interface and fix Monaco editor rendering bug where editor renders extremely small instead of filling available vertical space. Implement hybrid CSS base + Shadcn overrides approach: reduce base font in globals.css (16px → 12px), then override Shadcn component sizes explicitly. Fix Monaco editor with absolute positioning wrapper to give Monaco measurable dimensions.
  - **Assignee**: `senior-frontend-engineer`, `qa-test-automation-engineer`
  - **Files**:
    - **MODIFY**: `src/styles/globals.css` - Reduce root font-size from 16px to 12px
    - **MODIFY**: `src/components/ui/button.tsx` - Update default and small variant sizing
    - **MODIFY**: `src/components/ui/input.tsx` - Reduce height and padding
    - **MODIFY**: `src/components/ui/label.tsx` - Change text-sm to text-xs
    - **MODIFY**: `src/components/layout/PanelSubheader.tsx` - Reduce height and font size
    - **MODIFY**: `src/features/editor/components/EditorPane.tsx` - Add absolute positioning wrapper for Monaco
    - **MODIFY**: `src/features/editor/components/Editor.tsx` - Verify font size preservation (14px)
  - **Step Dependencies**: Phase 5, Step 3c
  - **User Instructions**: (1) All UI text is ~25% smaller (12px base vs 16px), (2) Monaco editor fills vertical space from subheader to footer, (3) Editor font remains at 14px for code readability, (4) All breakpoints render without overflow (375px, 768px, 1920px), (5) Panel resizing works smoothly at all widths, (6) Build passes without errors. Full implementation details and design rationale in `docs/plans/compact-ui-editor-fix-design.md` and validation guide in `PRPs/P5S3d-compact-ui-and-monaco-editor-fix.md`.

- Step 4: Editor UI with Manual Save
  - **Task**: Connect the `EditorPane` to the backend. The "Save" button should invoke the `saveNewVersion` action. Implement loading and success states for the save button. The editor should be populated with the selected prompt's content. Also reduce the default editor font size to 13px and provide useful monaco editor tools for editing and styling the content like a text editor customized and optimized for Markdown format (i.e. headers,tables, etc)
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/features/editor/components/EditorPane.tsx`: Add state management for title and content, and an onClick handler for the "Save" button to call the server action.
  - **Step Dependencies**: Phase 5, Step 3c
  - **User Instructions**: Select a prompt, type content into the editor, and click "Save". The content should persist after selecting another prompt and coming back. Check the `PromptVersions` and `Prompts` tables in Supabase to confirm that a new version was created and the content was updated.

- Step 4b: [P] Fix Critical Bugs, Subheader Design, and Tooltip System
  - **Task**: Fix critical EditorPane content sync bug causing wrong documents to display, implement Zustand refetch triggers for immediate UI updates after CRUD operations, standardize subheader designs with icon-only buttons, and integrate shadcn Tooltip component with 700ms hover delay across all interactive controls.
  - **Assignee**: `senior-frontend-engineer`
  - **Files**:
    - **MODIFY**: `src/features/editor/components/EditorPane.tsx` - Add content reset effect
    - **MODIFY**: `src/stores/use-ui-store.ts` - Add refetch triggers
    - **MODIFY**: `src/features/folders/components/FolderTree.tsx` - Use refetch trigger
    - **MODIFY**: `src/features/folders/components/FolderToolbar.tsx` - Trigger refetch, add tooltips
    - **MODIFY**: `src/features/prompts/components/PromptList.tsx` - Use refetch trigger
    - **MODIFY**: `src/features/prompts/components/DocumentToolbar.tsx` - Icon buttons, tooltips, trigger refetch
    - **MODIFY**: `src/app/(app)/layout.tsx` - Add TooltipProvider wrapper
    - **CREATE**: `src/components/ui/tooltip.tsx` - Shadcn tooltip component
  - **Step Dependencies**: Phase 5, Step 4
  - **User Instructions**: (1) Switching documents shows correct content immediately, (2) CRUD operations update UI without page reload, (3) All subheader buttons use consistent icon design, (4) All interactive controls show tooltips after 700ms hover, (5) Tooltip text is descriptive and context-aware. Full implementation details in `PRPs/P5S4b-fix-subheader-tooltips-design.md`.

- Step 4c: [P] Tabbed Editor Upgrade with Multi-Document Support
  - **Task**: Transform the Editor pane (column 3) into a VSCode-like tabbed-document container supporting multiple open documents simultaneously. Implement tab drag-and-drop for reordering, horizontal/vertical splitting for side-by-side editing, and tab stacking. Integrate all application pages (settings, profile, dashboard, version history) as tabs within the editor pane alongside document tabs. Each tab displays the document title with a close button. Use flexlayout-react or dnd-kit for advanced tab management with TypeScript support.
  - **Assignee**: `senior-frontend-engineer`, `ux-ui-designer`
  - **Files**:
    - **CREATE**: `src/features/tabs/components/TabbedEditorContainer.tsx` - Main tabbed container with split/stack support
    - **CREATE**: `src/features/tabs/components/DocumentTab.tsx` - Individual tab component with title and close button
    - **CREATE**: `src/features/tabs/components/TabContent.tsx` - Content renderer for different tab types
    - **CREATE**: `src/features/tabs/hooks/useTabManager.ts` - Hook for managing tab state, opening/closing tabs
    - **CREATE**: `src/features/tabs/types.ts` - TypeScript types for tab system (TabType, TabData, etc.)
    - **CREATE**: `src/stores/use-tab-store.ts` - Zustand store for tab state management
    - **MODIFY**: `src/app/(app)/layout.tsx` - Replace EditorPane with TabbedEditorContainer
    - **MODIFY**: `src/features/prompts/components/PromptList.tsx` - Update to open documents as tabs
    - **MODIFY**: `src/features/editor/components/EditorPane.tsx` - Refactor as tab content component
    - **MODIFY**: `src/app/(app)/settings/page.tsx` - Export as tab-compatible component
    - **MODIFY**: `src/app/(app)/dashboard/page.tsx` - Export as tab-compatible component
    - **MODIFY**: `src/app/(app)/profile/page.tsx` - Export as tab-compatible component
    - **MODIFY**: `src/components/layout/Header.tsx` - Add navigation to open settings/profile as tabs
    - `package.json`: Add flexlayout-react or @dnd-kit/core + @dnd-kit/sortable
  - **Step Dependencies**: Phase 5, Step 4b
  - **User Instructions**: (1) Multiple documents can be open in tabs simultaneously, (2) Tabs can be dragged to reorder, (3) Tabs can be split horizontally/vertically for side-by-side viewing, (4) Settings, profile, dashboard open as tabs in editor pane, (5) Each tab shows document title and close button, (6) Tab state persists in localStorage, (7) Keyboard shortcuts: Ctrl+W closes tab, Ctrl+Tab switches tabs. Full implementation details in `PRPs/P5S4c-tabbed-editor-upgrade.md`.

- Step 4e: [P] Improved Document Naming and Save Workflow
  - **Task**: Enhance the document creation and naming workflow to enforce proper title validation before persisting documents to the database. New documents are created with empty `title` field (database allows null temporarily) but display "[Untitled Doc]" or "[Untitled Doc N]" as placeholder labels in UI. Implement mandatory title validation on manual save (Save Version button) that prevents saving with empty or temporary placeholder titles. Add modal dialog to prompt user for title if they attempt to save without a valid title. Implement close-tab confirmation dialog that triggers when user closes an unsaved new document (not yet persisted), offering save/discard options with title entry flow if needed. Only persist documents to database after explicit Save Version action with valid title.
  - **Assignee**: `senior-frontend-engineer`, `ux-ui-designer`
  - **Files**:
    - **MODIFY**: `src/features/prompts/actions.ts` - Update createPrompt to create document with empty title in database, add title validation to renamePrompt and saveNewVersion
    - **MODIFY**: `src/features/prompts/schemas.ts` - Add validation schema for title requirements (non-empty, not placeholder pattern)
    - **MODIFY**: `src/features/editor/components/EditorPane.tsx` - Add title validation before saveNewVersion, trigger SetTitleDialog if invalid
    - **CREATE**: `src/features/prompts/components/SetTitleDialog.tsx` - Modal dialog for setting document title with validation
    - **CREATE**: `src/features/tabs/components/UnsavedChangesDialog.tsx` - Confirmation dialog for closing unsaved new documents
    - **MODIFY**: `src/stores/use-tab-store.ts` - Add closeTab interceptor to check for unsaved new documents, track "isNewDocument" flag
    - **MODIFY**: `src/features/tabs/types.ts` - Add isNewDocument boolean flag to TabData interface
    - **MODIFY**: `src/features/prompts/components/PromptList.tsx` - Display "[Untitled Doc N]" label for documents with empty title
    - **MODIFY**: `src/features/tabs/components/DocumentTab.tsx` - Display "[Untitled Doc N]" label for documents with empty title
  - **Step Dependencies**: Phase 5, Step 4c
  - **User Instructions**: (1) Creating new document shows "[Untitled Doc]" label in list and tab, (2) Cannot save with Save Version button until valid title is set, (3) Attempting to save without title opens SetTitleDialog modal, (4) Closing unsaved new document tab triggers UnsavedChangesDialog, (5) Can save from close dialog which then prompts for title if needed, (6) Canceling title dialog keeps document unsaved in tab, (7) Database only persists documents after explicit Save Version with valid title, (8) Title validation rejects empty strings and placeholder patterns like "[Untitled Doc]". Full implementation details in `PRPs/P5S4d-improved-document-naming.md`.

- Step 5: Fix Document Contamination and Race Conditions
  - **Task**: 
  1. Archon Task P5S5T8 - Complete implementation plan
  2. Analysis Document - /wip/P5S5T8-document-contamination-race-condition-analysis.md

  Part 1: Fix useLocalStorage (30 min)
  - Replace ref comparison with justLoadedRef flag
  - Remove key from save effect dependencies
  - Prevents save during key transitions
  Part 2: Clear State Before Load (30 min)
  - Add synchronous state clears in EditorPane
  - No window with old content + new promptId
  Part 3: Extend Transition Guards (30 min)
  - Don't release isTransitioning until states settle
  - Add content ownership validation to all saves
  Part 4: Testing (90 min)
  - Rapid document switching tests
  - New document creation tests
  - localStorage/cache isolation verification

  Expected Results:
  Before Fix:
  - ❌ New docs show old content
  - ❌ Titles change between tabs
  - ❌ Content bleeding on rapid switching
  - ❌ Flashing/incorrect content visible
  After Fix:
  - ✅ New docs always empty
  - ✅ Titles stay with correct documents
  - ✅ Clean content isolation
  - ✅ VSCode-like instant tab switching
  - ✅ No race conditions
  Priority:
  This should be the #1 priority before any other bug fixes:
  CRITICAL PRIORITY ORDER:
  1. P5S5T8 - Fix content contamination (BLOCKING)
  2. P5S5T1 - Fix infinite render loop
  3. P5S5T2 - Remove redundant requests
  4. P5S5T3 - Optimistic updates
  ... (other tasks)

  Reason: Users can work around slow requests, but contaminated content is a data integrity violation that undermines trust in the application.

- Step 6: [P] Version History UI
  - **Task**: Create a `VersionHistory.tsx` component. This component will display a list of all saved versions for a prompt, fetched via a new `getPromptVersions` server action. This can be displayed in a modal or a side panel.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/features/editor/actions.ts`: Add the `getPromptVersions` action.
    - `src/features/editor/components/VersionHistory.tsx`: The UI component to list versions.
    - `src/features/editor/components/EditorPane.tsx`: Add a "History" button to open the version history view.
  - **Step Dependencies**: Phase 5, Step 5
  - **User Instructions**: After saving a prompt multiple times, click the "History" button. A list or panel should appear showing an entry for each time you saved, with a timestamp.

## Phase 6: Final Features & Polish

- Step 1: [P] Full-Text Search Implementation
  - **Task**: Implement the database trigger to update the `content_tsv` column on prompt changes. Create the `searchPrompts` server action that uses Prisma's raw query capabilities to search against this column. Build a search bar UI component.
  - **Assignee**: `Database_Admin`
  - **Files**:
    - `wip/T6.1-fts-trigger.sql`: SQL script for the FTS trigger and function.
    - `src/features/search/actions.ts`: The `searchPrompts` server action.
    - `src/features/search/components/SearchBar.tsx`: The UI component for the search input.
    - `src/app/(app)/layout.tsx`: Integrate the `SearchBar` and the search results view.
  - **Step Dependencies**: Phase 3, Step 1
  - **User Instructions**: Run the SQL script in Supabase. Use the new search bar in the UI to type a keyword that exists in one of your prompts. The center pane should update to show the relevant prompt(s) as search results.

- Step 2: [P] Tagging System (UI and Logic)
  - **Task**: Implement the full tagging feature. Create server actions to add/remove tags from a prompt. Build the tag input UI in the `EditorPane` that allows adding and removing tags as pills. Display tags in the `PromptList` and make them clickable to filter the list.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/features/tags/actions.ts`: Server actions for managing tags.
    - `src/features/tags/components/TagInput.tsx`: The UI for adding/removing tags.
    - `src/features/editor/components/EditorPane.tsx`: Integrate the `TagInput`.
    - `src/features/prompts/components/PromptList.tsx`: Display tags and handle filtering logic.
  - **Step Dependencies**: Phase 5, Step 4
  - **User Instructions**: Add tags to a few prompts. The tags should appear as pills. Clicking on a tag in the prompt list should filter the view to show only prompts with that tag.

- Step 3: Final Testing and Quality Assurance
  - **Task**: Write and run a suite of tests for the application. Use Vitest for critical server actions (e.g., `saveNewVersion`, `createFolder`) and Playwright for end-to-end user flows (sign up -> create folder -> create prompt -> save prompt).
  - **Assignee**: `QA_Engineer`
  - **Files**:
    - `src/features/editor/actions.test.ts`: Example Vitest file for editor actions.
    - `tests/e2e/auth.spec.ts`: Example Playwright test for the authentication flow.
    - `tests/e2e/prompts.spec.ts`: Example Playwright test for the core prompt creation flow.
  - **Step Dependencies**: Phase 6, Step 2
  - **User Instructions**: Run `npm test`. All unit and E2E tests should pass, ensuring the application is stable and functions as expected.

- Step 4: PRP Completion Report
  - **Task**: Create the final PRP completion report. This document will summarize the work completed, detail the final state of the application, list any challenges encountered, and confirm that all requirements from the technical specification have been met.
  - **Assignee**: `Lead_Architect`
  - **Files**:
    - `PRPs/reports/prompthub-v1-REPORT.md`: The final project completion report.
  - **Step Dependencies**: Phase 6, Step 3
  - **User Instructions**: Review the final report to get a comprehensive overview of the project's execution and outcomes.