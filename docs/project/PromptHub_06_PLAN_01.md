# PromptHub - Implementation Plan

## Phase 1: Project Initialization and Core Setup

- Step 1: [P] Initial Project Setup & Dependency Installation
  - **Task**: Initialize a new Next.js project using the App Router, TypeScript, and Tailwind CSS. Install all core dependencies specified in the technical documentation, including Prisma, Zod, Supabase clients, shadcn/ui, Zustand, Framer Motion, and Monaco Editor. Configure TypeScript (`tsconfig.json`) and Tailwind CSS (`tailwind.config.ts`) according to the project's style guide and structure.
  - **Assignee**: `Lead_Architect`
  - **Files**:
    - `package.json`: To add all project dependencies.
    - `tsconfig.json`: To configure TypeScript paths and strictness.
    - `tailwind.config.ts`: To set up theme variables, fonts, and plugins.
    - `next.config.mjs`: Basic Next.js configuration.
    - `.gitignore`: To exclude `node_modules`, `.env`, and other non-essential files.
  - **Step Dependencies**: None
  - **User Instructions**: Run `npm install` to verify all dependencies are installed correctly. The project should be able to start in development mode (`npm run dev`) without errors.

- Step 2: [P] Supabase Project Setup & Environment Configuration
  - **Task**: Create a new project on Supabase. Retrieve the project URL and anon key. Set up the `.env` file with the required Supabase and database URL variables (`NEXT_PUBLIC_SUPABASE_URL`, `NEXT_PUBLIC_SUPABASE_ANON_KEY`, `DATABASE_URL`, `DIRECT_URL`).
  - **Assignee**: `Database_Admin`
  - **Files**:
    - `.env`: To store all secret keys and environment variables.
    - `.env.example`: To provide a template for required environment variables.
  - **Step Dependencies**: None
  - **User Instructions**: Check the Supabase project dashboard to confirm it's running. Ensure the `.env` file is populated with the correct credentials.

- Step 3: [P] PRP Initialization and Documentation Structure
  - **Task**: Create the required project documentation and reporting structure. This includes the `PRPs/docs`, `PRPs/reports`, and `wip` folders. Generate the initial PRP start report detailing the full plan of execution.
  - **Assignee**: `Lead_Architect`
  - **Files**:
    - `PRPs/reports/prompthub-v1-INITIAL.md`: The initial plan document.
    - `PRPs/docs/.gitkeep`: To create the directory.
    - `wip/.gitkeep`: To create the directory.
  - **Step Dependencies**: None
  - **User Instructions**: Verify that the specified folder structure (`PRPs/docs`, `PRPs/reports`, `wip`) exists at the project root.

- Step 4: Prisma Schema Definition & Initial Migration
  - **Task**: Translate the data models from the technical specification into a `schema.prisma` file. Define all models: `Profile`, `Folder`, `Prompt`, `PromptVersion`, and `Tag`. Set up relations, indexes, and onDelete cascade behaviors. Run the initial Prisma migration to sync the schema with the Supabase database.
  - **Assignee**: `Database_Admin`
  - **Files**:
    - `prisma/schema.prisma`: To define the complete database schema.
    - `prisma/migrations/0000_initial_schema/migration.sql`: Generated by Prisma to create the initial database structure.
  - **Step Dependencies**: Phase 1, Step 2
  - **User Instructions**: Run `npx prisma migrate dev --name initial-schema`. Verify in the Supabase Table Editor that all tables (`Profile`, `Folder`, `Prompt`, etc.) and their respective columns have been created correctly.

- Step 5: [P] Global Styles & Theme Foundation
  - **Task**: Configure the global CSS file (`src/styles/globals.css`) with the base Tailwind directives. Define all color system CSS variables for both light and dark modes as specified in the UI/UX and Style guides. Set up the primary and monospace font families.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/styles/globals.css`: To implement the core color and typography theming variables.
    - `src/app/layout.tsx`: To apply the font classes to the root layout.
  - **Step Dependencies**: Phase 1, Step 1
  - **User Instructions**: Inspect the application in the browser. The background color and default font should match the style guide.

- Step 6: [P] Core Library & Utility Configuration
  - **Task**: Set up singleton instances for the Prisma client and Supabase client. Create a `src/lib/` directory to house these configurations, ensuring they are reusable throughout the application.
  - **Assignee**: `Backend_Engineer`
  - **Files**:
    - `src/lib/db.ts`: To export a single, global instance of the Prisma client.
    - `src/lib/supabase.ts`: To configure and export Supabase client instances for client-side and server-side usage.
    - `src/lib/utils.ts`: To initialize the `cn` utility function from `shadcn/ui`.
  - **Step Dependencies**: Phase 1, Step 1; Phase 1, Step 2
  - **User Instructions**: This is a configuration step. Code should compile without errors.

- Step 7: `shadcn/ui` Initialization and Core Component Setup
  - **Task**: Initialize `shadcn/ui` in the project. Install a foundational set of components that will be used globally, such as `Button`, `Input`, `Card`, and `Toast`.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `components.json`: Configuration file for `shadcn/ui`.
    - `src/components/ui/button.tsx`: The Button component.
    - `src/components/ui/input.tsx`: The Input component.
    - `src/components/ui/card.tsx`: The Card component.
    - `src/components/ui/toaster.tsx`: The Toaster component for notifications.
    - `src/app/layout.tsx`: To add the `<Toaster />` component to the root layout.
  - **Step Dependencies**: Phase 1, Step 1; Phase 1, Step 5
  - **User Instructions**: Start the dev server. The application should render correctly. No visual changes are expected yet, but the component files should exist.

## Phase 2: Authentication & User Management

- Step 1: [P] Supabase Auth Trigger for Profile Creation
  - **Task**: Write and execute a SQL script in the Supabase dashboard to create a trigger. This trigger will automatically insert a new row into the public `Profile` table whenever a new user signs up and is added to the `auth.users` table.
  - **Assignee**: `Database_Admin`
  - **Files**:
    - `wip/T2.1-supabase-profile-trigger.sql`: A working file containing the SQL for the trigger and function.
  - **Step Dependencies**: Phase 1, Step 4
  - **User Instructions**: In the Supabase SQL Editor, run the script to create the function and trigger. Manually add a test user in the Supabase Auth dashboard and verify that a corresponding entry is created in the `Profile` table.

- Step 2: [P] Authentication UI Components (Login/Sign Up Form)
  - **Task**: Create the authentication form component (`AuthForm.tsx`). This component will handle both sign-in and sign-up states, toggling between them. Style the form using `shadcn/ui` components (`Card`, `Input`, `Button`) according to the UI/UX guide.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/features/auth/components/AuthForm.tsx`: The main UI component for authentication.
    - `src/app/(auth)/login/page.tsx`: The route that will render the `AuthForm`.
    - `src/app/(auth)/layout.tsx`: A simple layout for centering the auth form on the page.
  - **Step Dependencies**: Phase 1, Step 7
  - **User Instructions**: Navigate to `/login`. A styled form for signing in and signing up should be visible and match the design specifications.

- Step 3: Authentication Server Actions (Sign Up, Sign In, Sign Out)
  - **Task**: Implement the backend logic for authentication using Next.js Server Actions. Create `signUp`, `signIn`, and `signOut` actions. Use Zod for input validation and the Supabase SSR client for handling authentication logic.
  - **Assignee**: `Backend_Engineer`
  - **Files**:
    - `src/features/auth/actions.ts`: To contain the `signUp`, `signIn`, and `signOut` server actions.
    - `src/features/auth/schemas.ts`: To define the Zod schemas for sign-up and sign-in forms.
    - `src/features/auth/components/AuthForm.tsx`: Update the form to invoke these server actions on submit.
  - **Step Dependencies**: Phase 1, Step 6; Phase 2, Step 2
  - **User Instructions**: Test the full authentication flow. A new user should be able to sign up, log out, and log back in. Check the Supabase Auth dashboard to confirm user creation.

- Step 4: Protected Route Middleware
  - **Task**: Implement Next.js middleware to protect application routes. The middleware will check for a valid user session using the Supabase SSR client. Unauthenticated users attempting to access protected routes (e.g., the main app) will be redirected to the `/login` page.
  - **Assignee**: `Security_Specialist`
  - **Files**:
    - `src/middleware.ts`: The middleware logic for protecting routes.
  - **Step Dependencies**: Phase 2, Step 3
  - **User Instructions**: After logging out, attempt to navigate directly to the application's root URL (`/`). You should be redirected to `/login`. After logging in, you should be redirected to the main application page.

- Step 5: Basic Application Layout and User Display
  - **Task**: Create the main three-pane application layout for authenticated users. This includes a placeholder for the folder sidebar, prompt list, and editor. Fetch the current user's data and display their name or email in the header, along with a functional "Sign Out" button.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/app/(app)/layout.tsx`: The main 3-pane layout for the authenticated application.
    - `src/app/(app)/page.tsx`: The default page shown to logged-in users.
    - `src/components/layout/Header.tsx`: A new component to display user info and the sign-out button.
  - **Step Dependencies**: Phase 2, Step 3; Phase 2, Step 4
  - **User Instructions**: Log in to the application. You should see a basic layout with a header displaying your user information and a working "Sign Out" button.

## Phase 3: Data Security and Core Data Access

- Step 1: Row Level Security (RLS) Policies
  - **Task**: Implement Row Level Security (RLS) policies for all tables containing user-specific data (`Profile`, `Folder`, `Prompt`, `Tag`). Write SQL policies that ensure users can only perform CRUD operations on their own data.
  - **Assignee**: `Security_Specialist`
  - **Files**:
    - `wip/T3.1-rls-policies.sql`: A working file containing all RLS policies for all tables.
  - **Step Dependencies**: Phase 2, Step 1
  - **User Instructions**: In the Supabase SQL Editor, enable RLS on all relevant tables and apply the policies. This is a critical security step and can be tested implicitly in subsequent steps as data access is implemented.

## Phase 4: Prompt Organization & Retrieval

- Step 1: [P] Folder Data Access Server Actions
  - **Task**: Create the server actions required for folder management. Implement `getRootFolders` and `getFolderChildren` to enable lazy-loading of the folder tree. These actions will use Prisma to query the database.
  - **Assignee**: `Backend_Engineer`
  - **Files**:
    - `src/features/folders/actions.ts`: To contain server actions for fetching folder data.
  - **Step Dependencies**: Phase 3, Step 1
  - **User Instructions**: This is a backend-only step. The actions should be implemented and ready for the frontend to consume.

- Step 2: [P] Zustand Store for UI State
  - **Task**: Set up a Zustand store to manage global UI state. The initial store will handle the expanded/collapsed state of folders in the folder tree and track the currently selected folder and prompt.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/stores/use-ui-store.ts`: The Zustand store definition for managing UI state.
  - **Step Dependencies**: Phase 1, Step 1
  - **User Instructions**: This is a setup step. The store should be created and ready to be used by UI components.

- Step 3: Folder Tree UI Component
  - **Task**: Build the `FolderTree.tsx` component. This component will fetch the initial root folders using the server action from Step 1. It will render `FolderItem` components recursively. Implement lazy-loading: when a user clicks to expand a folder, it should call the `getFolderChildren` action and render the sub-folders. Use the Zustand store to manage the expanded state.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/features/folders/components/FolderTree.tsx`: The main container for the folder hierarchy.
    - `src/features/folders/components/FolderItem.tsx`: A recursive component to display a single folder, its children, and handle expansion.
    - `src/app/(app)/layout.tsx`: Integrate the `FolderTree` component into the left sidebar.
  - **Step Dependencies**: Phase 4, Step 1; Phase 4, Step 2
  - **User Instructions**: Log in and view the application. The left sidebar should be empty initially. After creating some folders (in the next step), you should be able to see them, expand them to load sub-folders, and collapse them.

- Step 4: Folder Creation and Management Actions & UI
  - **Task**: Implement the `createFolder`, `renameFolder`, and `deleteFolder` server actions. Add UI elements (e.g., a "New Folder" button, context menus on folder items) to the `FolderTree` component to invoke these actions. Use optimistic or pessimistic updates with clear loading states. Use `revalidatePath` to ensure the folder tree refreshes after a mutation.
  - **Assignee**: `Backend_Engineer`
  - **Files**:
    - `src/features/folders/actions.ts`: Add the mutation server actions.
    - `src/features/folders/components/FolderTree.tsx`: Add the "New Folder" button.
    - `src/features/folders/components/FolderItem.tsx`: Add a context menu (using `shadcn/ui` DropdownMenu) for rename and delete actions.
  - **Step Dependencies**: Phase 4, Step 3
  - **User Instructions**: You should now be able to create new folders and nested sub-folders. Right-clicking a folder should allow you to rename or delete it. The UI should update automatically after each action.

- Step 5: Prompt List Component
  - **Task**: Create the `PromptList.tsx` component for the center pane. When a folder is selected in the `FolderTree`, this component should display a list of prompts within that folder. Implement the `getPromptsByFolder` server action.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/features/prompts/actions.ts`: To create the `getPromptsByFolder` server action.
    - `src/features/prompts/components/PromptList.tsx`: The UI component to display the list of prompts.
    - `src/app/(app)/layout.tsx`: Integrate the `PromptList` into the center pane of the layout.
  - **Step Dependencies**: Phase 4, Step 4
  - **User Instructions**: When you click on a folder in the left sidebar, the center pane should update to show a (currently empty) list of prompts for that folder.

## Phase 5: Prompt Editor & Version Control

- Step 1: [P] Monaco Editor Integration
  - **Task**: Create a wrapper component for the Monaco Editor (`Editor.tsx`). This component should be dynamically imported to prevent SSR issues. Configure it with a dark theme and basic options.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/features/editor/components/Editor.tsx`: The wrapper component for `@monaco-editor/react`.
  - **Step Dependencies**: Phase 1, Step 1
  - **User Instructions**: This is a foundational component. No direct UI to test yet, but the component should be ready for integration.

- Step 2: [P] Prompt Creation and Data Access
  - **Task**: Implement the `createPrompt` and `getPromptDetails` server actions. Add a "New Prompt" button to the `PromptList` component. When a new prompt is created or an existing one is selected, the right-hand pane should render the editor view.
  - **Assignee**: `Backend_Engineer`
  - **Files**:
    - `src/features/prompts/actions.ts`: Add `createPrompt` and `getPromptDetails` actions.
    - `src/features/prompts/components/PromptList.tsx`: Add the "New Prompt" button.
    - `src/features/editor/components/EditorPane.tsx`: A new component for the right pane that will contain the title input and the Monaco Editor.
    - `src/app/(app)/layout.tsx`: Integrate `EditorPane` into the right pane.
  - **Step Dependencies**: Phase 4, Step 5; Phase 5, Step 1
  - **User Instructions**: In a selected folder, click "New Prompt". A new prompt should appear in the center list, and the right pane should display an editor view with an empty title and content area.

- Step 3: Prompt Saving and Versioning Logic
  - **Task**: Implement the `saveNewVersion` server action. This action will receive the prompt's new content, calculate a diff from the most recent version, and store this diff in the `PromptVersions` table. It will also update the main `content` field in the `Prompts` table.
  - **Assignee**: `Backend_Engineer`
  - **Files**:
    - `src/features/editor/actions.ts`: To contain the `saveNewVersion` server action.
    - `package.json`: Add `diff-match-patch` dependency.
  - **Step Dependencies**: Phase 5, Step 2
  - **User Instructions**: This is a backend step. The logic for creating versions should be complete and ready for the UI to use.

- Step 3b: [P] Improved UI Update: Layout, Editor, Toolbars & Features
  - **Task**: Transform the UI from basic 3-panel layout into a professional application with: (1) Full-height Monaco editor with scrolling and toolbar, (2) Duplicate title prevention, (3) Subfolder creation capability, (4) Consistent panel subheaders with context-aware toolbars, (5) Comprehensive sort/filter systems for folders and documents, (6) Auto-save with manual versioning (auto-save updates current content, manual save creates versions), (7) Placeholder UI for future features (version history, dashboard, settings).
  - **Assignee**: `senior-frontend-engineer`, `ux-ui-designer`
  - **Files**:
    - **CREATE**: `src/components/layout/PanelSubheader.tsx` - Reusable subheader component
    - **CREATE**: `src/features/editor/hooks/useAutoSave.ts` - Debounced auto-save hook
    - **CREATE**: `src/features/editor/hooks/useLocalStorage.ts` - localStorage persistence hook
    - **CREATE**: `src/features/editor/schemas.ts` - Validation schemas
    - **CREATE**: `src/features/folders/components/FolderToolbar.tsx` - Folder operations toolbar
    - **CREATE**: `src/features/prompts/components/DocumentToolbar.tsx` - Document operations toolbar
    - **CREATE**: `src/app/(app)/dashboard/page.tsx` - Dashboard placeholder
    - **MODIFY**: `src/app/(app)/layout.tsx` - Add 3 subheaders, fix panel heights
    - **MODIFY**: `src/features/editor/components/EditorPane.tsx` - Fix flex layout for full-height Monaco
    - **MODIFY**: `src/features/editor/components/Editor.tsx` - Enable full Monaco features
    - **MODIFY**: `src/features/editor/actions.ts` - Add autoSavePrompt action
    - **MODIFY**: `src/features/folders/components/FolderItem.tsx` - Add recursive subfolder support
    - **MODIFY**: `src/features/folders/components/FolderTree.tsx` - Integrate toolbar
    - **MODIFY**: `src/features/prompts/actions.ts` - Add duplicate title validation
    - **MODIFY**: `src/features/prompts/components/PromptList.tsx` - Rename to "Documents", integrate toolbar
    - **MODIFY**: `src/stores/use-ui-store.ts` - Add sort/filter state
    - **MODIFY**: `src/lib/utils.ts` - Add debounce utility
    - **MODIFY**: `src/app/(app)/settings/page.tsx` - Add placeholder sections
  - **Step Dependencies**: Phase 5, Step 3
  - **User Instructions**: (1) Monaco editor extends from title to footer on all screen sizes, (2) Cannot create duplicate titles (case-insensitive), (3) Can create subfolders up to 5 levels, (4) Three aligned subheaders visible with toolbars, (5) Sort/filter controls functional, (6) Auto-save triggers after 500ms typing pause, Ctrl+S creates version, (7) Version history button present (disabled), dashboard/settings pages render. Full validation checklist and testing guide in `PRPs/P5S3b-improved-ui-update.md`.

- Step 3c: [P] Fix Subheader Layout with Resizable Columns
  - **Task**: Transform fixed-width 3-column layout into user-resizable layout with animated drag handles. Install `react-resizable-panels`, create AnimatedResizeHandle and ResizablePanelsLayout components, update main layout to use resizable panels, and add responsive classes to toolbars. Column widths persist in localStorage, handles animate smoothly toward cursor, and min/max constraints prevent UI breakage.
  - **Assignee**: `senior-frontend-engineer`, `qa-test-automation-engineer`
  - **Files**:
    - **CREATE**: `src/components/layout/AnimatedResizeHandle.tsx` - Custom drag handle with framer-motion animations
    - **CREATE**: `src/components/layout/ResizablePanelsLayout.tsx` - Client wrapper with PanelGroup
    - **MODIFY**: `src/app/(app)/layout.tsx` - Use ResizablePanelsLayout instead of fixed divs
    - **MODIFY**: `src/features/folders/components/FolderToolbar.tsx` - Add responsive classes
    - **MODIFY**: `src/features/prompts/components/DocumentToolbar.tsx` - Add responsive classes
    - **MODIFY**: `src/features/editor/components/EditorPane.tsx` - Verify responsive behavior
    - `package.json`: Add `react-resizable-panels` dependency
  - **Step Dependencies**: Phase 5, Step 3b
  - **User Instructions**: (1) Columns can be resized by dragging vertical separators, (2) Drag handles animate smoothly toward cursor when nearby and return to center when released, (3) Column widths persist across page reloads, (4) Toolbar content fits properly at all column widths without overflow, (5) Touch and keyboard navigation work correctly. Full implementation details and testing guide in `PRPs/P5S3c-fix-subheader-layout-resizable-columns.md`.

- Step 4: Editor UI with Manual Save
  - **Task**: Connect the `EditorPane` to the backend. The "Save" button should invoke the `saveNewVersion` action. Implement loading and success states for the save button. The editor should be populated with the selected prompt's content.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/features/editor/components/EditorPane.tsx`: Add state management for title and content, and an onClick handler for the "Save" button to call the server action.
  - **Step Dependencies**: Phase 5, Step 3c
  - **User Instructions**: Select a prompt, type content into the editor, and click "Save". The content should persist after selecting another prompt and coming back. Check the `PromptVersions` and `Prompts` tables in Supabase to confirm that a new version was created and the content was updated.

- Step 5: [P] Version History UI
  - **Task**: Create a `VersionHistory.tsx` component. This component will display a list of all saved versions for a prompt, fetched via a new `getPromptVersions` server action. This can be displayed in a modal or a side panel.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/features/editor/actions.ts`: Add the `getPromptVersions` action.
    - `src/features/editor/components/VersionHistory.tsx`: The UI component to list versions.
    - `src/features/editor/components/EditorPane.tsx`: Add a "History" button to open the version history view.
  - **Step Dependencies**: Phase 5, Step 4
  - **User Instructions**: After saving a prompt multiple times, click the "History" button. A list or panel should appear showing an entry for each time you saved, with a timestamp.

## Phase 6: Final Features & Polish

- Step 1: [P] Full-Text Search Implementation
  - **Task**: Implement the database trigger to update the `content_tsv` column on prompt changes. Create the `searchPrompts` server action that uses Prisma's raw query capabilities to search against this column. Build a search bar UI component.
  - **Assignee**: `Database_Admin`
  - **Files**:
    - `wip/T6.1-fts-trigger.sql`: SQL script for the FTS trigger and function.
    - `src/features/search/actions.ts`: The `searchPrompts` server action.
    - `src/features/search/components/SearchBar.tsx`: The UI component for the search input.
    - `src/app/(app)/layout.tsx`: Integrate the `SearchBar` and the search results view.
  - **Step Dependencies**: Phase 3, Step 1
  - **User Instructions**: Run the SQL script in Supabase. Use the new search bar in the UI to type a keyword that exists in one of your prompts. The center pane should update to show the relevant prompt(s) as search results.

- Step 2: [P] Tagging System (UI and Logic)
  - **Task**: Implement the full tagging feature. Create server actions to add/remove tags from a prompt. Build the tag input UI in the `EditorPane` that allows adding and removing tags as pills. Display tags in the `PromptList` and make them clickable to filter the list.
  - **Assignee**: `Frontend_Engineer`
  - **Files**:
    - `src/features/tags/actions.ts`: Server actions for managing tags.
    - `src/features/tags/components/TagInput.tsx`: The UI for adding/removing tags.
    - `src/features/editor/components/EditorPane.tsx`: Integrate the `TagInput`.
    - `src/features/prompts/components/PromptList.tsx`: Display tags and handle filtering logic.
  - **Step Dependencies**: Phase 5, Step 4
  - **User Instructions**: Add tags to a few prompts. The tags should appear as pills. Clicking on a tag in the prompt list should filter the view to show only prompts with that tag.

- Step 3: Final Testing and Quality Assurance
  - **Task**: Write and run a suite of tests for the application. Use Vitest for critical server actions (e.g., `saveNewVersion`, `createFolder`) and Playwright for end-to-end user flows (sign up -> create folder -> create prompt -> save prompt).
  - **Assignee**: `QA_Engineer`
  - **Files**:
    - `src/features/editor/actions.test.ts`: Example Vitest file for editor actions.
    - `tests/e2e/auth.spec.ts`: Example Playwright test for the authentication flow.
    - `tests/e2e/prompts.spec.ts`: Example Playwright test for the core prompt creation flow.
  - **Step Dependencies**: Phase 6, Step 2
  - **User Instructions**: Run `npm test`. All unit and E2E tests should pass, ensuring the application is stable and functions as expected.

- Step 4: PRP Completion Report
  - **Task**: Create the final PRP completion report. This document will summarize the work completed, detail the final state of the application, list any challenges encountered, and confirm that all requirements from the technical specification have been met.
  - **Assignee**: `Lead_Architect`
  - **Files**:
    - `PRPs/reports/prompthub-v1-REPORT.md`: The final project completion report.
  - **Step Dependencies**: Phase 6, Step 3
  - **User Instructions**: Review the final report to get a comprehensive overview of the project's execution and outcomes.